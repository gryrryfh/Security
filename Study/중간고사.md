## 1장 : 사이버 범죄와 악성코드    
Zero-Day 공격: 알려지지 않은 취약점 발견(해커들의 시간)    
One Day 공격: 발견된 최신 취약점의 패치 발표됨    
OlDay 공격: 취약점에 대하여 패치가 오래 전에 발표됨    
악성코드 : 시스템과 네트워크의 정상적인 사용을 저해하는 모든 종류의 코드(바이러스, 웜, 스파이웨어 등) 악성 소프트웨어, 멀웨어라고 함  
악성코드 증상 : 시작페이지변경, 윈도우설정변경, 파일삭제, 변경, 속도저하, 문서열리지않음 등  
  
사이버공격 : 2017년의 사이버 공격으로 한국의 손실액은약 77조 원  
사이버공격 전망 : 2019년 22위  
사이버공격 동향 : 랜섬웨어, 암호화폐 악성코드 등 증가  
  
사이버범죄 : 피싱, 스미싱, 파밍 등    
피싱 : 개인정보낚시   
스미싱 : 문자메시지피싱  
파밍 : IP 변조  

타이포스쿼팅: URL을 교묘하게 바꿔 가짜 사이트 생성  

바이러스 : 다양한 감염경로로 컴퓨터에침입하여 실행 가능한 파일이나 문서 파일 내에 복제되어 기생  
감염된 파일의 실행이나 오픈 시바이러스가 활동하여 컴퓨터에 악의적인피해를 입히거나 자신을 다른 파일에 복제하여 감염시킴  
   
실행파일 바이러스 : 국내의 80% 정도가 파일 바이러스로 가장 일반적인 유형  ex) 예루살렘 바이러스  
![image](https://github.com/gryrryfh/Security/assets/50912987/49ab282d-b720-48ca-bb7e-cded385d6de0)  

매크로 바이러스 : MS 워드, 엑셀과 같이 매크로 언어를 지원하는 문서파일에 기생 ex)멜리사, 라룩스  
감염된 문서 파일을 여는 순간 바이러스가 동작  감염 대상이 실행파일이 아닌 매크로 기능을 사용하는 문서파일  

스크립트 바이러스 : 스크립트언어로 작성 ex) 러브바이러스  
바이러스가 포함되어 있는 문서의 스크립트가 실행되면서 다른 파일을 감염시킴    
  
바이러스 이름 : CARO 규약에 따라 이름 붙이고 백신 개발 (운영체제/특성명칭/주여변수/보조변수)  
  
웜 : 독립적으로 존재하는 실행 가능한 프로그램 ex) 모리스 웜  
바이러스와 달리 특정 파일을 감염시키는 것이 아니라 웜 자신을 복제하여 배포  
슬래머웜 : MS-SQL 서버의 버퍼 오버플로우 취약점을 이용하여 서버 컴퓨터에 침입하고 자신을무제한 복제하며, 네트워크에 연결된 컴퓨터들의 동일한 취약점을 찾아 공격 10분만에 전세계로 퍼짐  
웜 바이러스 : 공격 대상 컴퓨터에 대한 침투까지는 웜의 방식, 침투가 완료된 이후에는 바이러스 방식으로 감염시킴 요즘 바이러스 형태  
트로이목마 : 악성 루틴이 숨어 있는 프로그램  트로이목마는 바이러스와 같이 자기 복제 기능이 없음 다운로드 파일들에서 나옴 지속적인 정보유출, 제어권 획득  
스파이에어 : 정보의 수집보다는 광고에 주력하는 프로그램으로 사용자에게 불편을 초래  
랜섬웨어 : 시스템을 잠그거나 데이터를 암호화하고이를 인질로 금전을 요구하는 악성 프로그램  

백신프로그램 : 악성코드를 찾아서 제거하는 기능을 갖춘 프로그램으로 바이러스, 웜, 트로이목마 등의 다양한 악성코드를 처리 (알약, 네이버 백신, 안랩 등)  
2장 암호 개념과 대칭키 암호시스템  
보안공격 : 수동공격(훔쳐보기), 능동공격(변조, 삽입, 삭제)  
보안서비스 : 기밀성(암호화), 무결성, 인증(전자서명)  
통계적 암호해독 : 영어의 각 문자가 문장 중에서 발생할 확률(에니그마)  
  
## 2장 암호의 개념과 대칭키 암호 시스템  
  
수동암호 시대 : ~1920 (치환암호, 전치 암호)    
치환암호(단일문자) : abcd == efgh  
치환암호(다중문자) : abcd == egjn 좀더 복잡함  
전치암호 : 전치테이블을 이용해 문장 내의 문자 위치 재배열  
![image](https://github.com/gryrryfh/Security/assets/50912987/78eaed91-4c96-43cb-b76e-28419fd548b0)  
   
기계암호 시대 : 1920~1950 (에니그마, 하겔린)  
컴퓨터시대 암호 : 1950~ (대칭키 암호 시스템, 비대칭키 암호 시스템=공개키암호시스템)  
대칭키 암호 시스템(암호화와 복호화에 동일한 키 사용)  
비대칭키 암호시스템=공개키암호시스템(송신자는 수신자의 공개키로 평문을 암호화 수신자는 자신의 개인키로 암호문을 복호화)  

Feistel 암호 : 최초의 암호 시스템(1973)  
2번 이상의 기본대치 및 순열치환(permutation)을 연속적으로 수행  
일반적으로 Feistel 연산은 짝수 라운드(DES에서는 16라운드) 적용  
키를 각 라운드에서 사용되는 서브키로 변환하는 키 스케줄 알고리즘 활용  
라운드 함수에 관계없이 역변환이 가능(암/복호화 과정이 같음)  

데이터암호화 표준(DES)  
56 비트의 키를 이용하는 대칭키 암호 시스템-l 데이터를 64비트 단위의 블록으로 분할 후, 순열, 배타적 OR, 회전 등으로 변경  
  
DES 기본연산  
순환 : 비트를 왼쪽이나 오른쪽으로 회전  
순열 : 비트 레벨의 치환  
![image](https://github.com/gryrryfh/Security/assets/50912987/bf17d651-2cd5-4e0a-a276-98719747e355)  

DES-암호화  
초기 치환 : 64비트 평문에 있는 각 비트의 위치를 바꿈    
  
서브키생성 : 동일한 절차를 수행하나 서로 다른 서브키 사용  
56비트키를 28비트 2개로 나누고 각각 좌순환, 결합 56비트 나옴 -> 압축순열로 48비트로 됨 이게 서브키1  
결합한 56비트를 2개로 나누고 각각 또 좌순환하고 압축순열로 48비트로 됨 이게 서브키2 이걸 16까지 반복  
64비트 입력을 32비트로 나누어서 위치를 교체  
64비트를 32비트 2개로 나눔 하나(R i-1, L i)는 다음단계로 또 하나(L i-1)는 (R i-1)을 확장순열하고 이것저것 함수한거랑 xor한 (R i)로 됨 이걸 반복  
위에 쓸 함수 : 32비트를 48비트로 확장하고 서브키랑 xor 그다음 s박스로 32비트를 만들고 일대일 순열하고 (l i-1)랑 xor하면 (R i)가 된다  
s박스 : 비트의 앞뒤가 행 가운데가 열 행열을 찾아 그 값을 출력  
s박스의 대체 : 혼동  
치호나 테이블 : 확산  
이전단계 출력인 64비트의 각 비트 위치를 바꿈  

복호화(역초기치환) : 서브키를 역으로 수행(암호할땐 1~16순서면 복호화할댄 16~1로 진행) 서브키 생성은 같은방법  

DES 취약점   
56비트가 안정성 문제(1997년 7만대 컴퓨터로 des키를 찾음, 99년에 22시간만에 키가 깨짐)  
그 후 3중 DES를 국가표준으로 채택(2030년까지 사용 가능) 안전, 대칭키중에선 가장 안전  
  
DES키 3개를 사용  평문을 des1로 암호화, 그 암호화한걸 des2로 복호화, 그걸 des3로 암호화 (복호화는 반대)  
높은 보안의 경우 des1,2,3는 모두 다른 키, 일반적인 경우에는 k1, k3는 동일한 키 사용  
  
SEED : 128비트 암호 알고리즘(웹브라우저 플러그인으로 배포) 이것도 fiestel 16라운드 네트워크  
  
블록 암호화 모드 : 특정 비트 수의 집합을 한번에 처리하는 암호 알고리즘 ex) DES, 3중 des, AES  
ECB모드 : 1대1 관계 취약  
CBC모드 : 초기백터를 이용해 복잡해짐 IPSEC통신에서 사용  
![image](https://github.com/gryrryfh/Security/assets/50912987/6d432742-427c-4722-b889-95d1ed1af27a)  
  
연산량 많음  
  
## 3장 AES와 공개키 암호시스템  
    
AES(진화된 암호화 표준)==공개키 암호시스템 ex)온라인뱅킹, 전자상거래  
diffie-hellman : 공개키 교환, 비밀키가 동일해짐(중간 공격자의 공격에 취약)   
AES 요구사항   
형태 : 대칭키 블록 암호 알고리즘   
효율성 : 삼중 DES보다 좋을 것  
비용 : 무료  
안전성 : 최소 128비트, 256비트 등등  
  
과정 : 평문(128비트)를 암호키(128비트)와 xor  
  
블록 : 128비트 입력,출력   
스테이트 : 128, 256비트 입력, 출력물을 4*4 이차원행렬로 표현   
shift row == 각행위 수만큼 왼쪽으로 이동  
Inv shift row== 복호화할때 쓰고 각 행위 수만큼 오른쪽으로 이동  
Mix column : 각 열을 상수 행렬과 곱하고 XOR (2의 8승을 넘으면 특정수랑 xor)  
Inv Mix column : 믹스컬럼의 역순  
Add Roundkey : 스테이트 입력값과 라운드 키의 xor  
라운드 키 생성구조 : Wi = Wi-1 xor Wi-4 단 i가 4의 배수면 wi = ti xor wi-4  
ti = wi-1을 1바이트 왼쪽 회전하고 각 바이트를 sbox로 대치하고 RCon i/4  
  
암호화 : subbyte, shift row, mix column, add round key를 10번 수행  
  
장점 : 병열연산 가능(효율적)  
단점 : 역함수 필요  
  
대칭키 암호시스템 : 암호화와 복호화에 동일한 키 사용,   
송신자와 수신자는 안전한 채널을 통해서 암호 키가 먼저 교환되어야 함   
상호통신 암호키 수 : (N*(N-1)/2)   
(비대칭키)공개키 암호시스템 : 암호 키의 개수는 2N  
공개키기법 : 디프헬만, rsa암호시스템 ->사람이름  
아이디어 : 일방향 함수 소수의 곱에서 소수찾기는 어렵다  
공개키로 암호알고리즘을 만드는건 쉽다  
개인키는 암호문->평문 쉽게 해결 가능  

법연산(모듈라) 나누었을때 나머지 : 최대공약수 구하는 알고리즘  

rsa 공개키 암호시스템 : 평문을 수신자의 공개키로 멱승해서 나눈 나머지 값이 암호문  
두 소수의 곱 : n  
암호문 = 평문^서버의 공개키(두 소수 중 하나) mod m  
평문 = 암호문^서버의 개인키(두 소수 중 하나) mod m  

rsa 암호시스템 생성 : 두 소수  2개가 있다,  이 소수의 곱은 공개가 된다,  
(소수-1) * (또다른소수-1)를 구하고 이녀석과 서로소인 공개키를 하나 선택,   
서로소랑 개인키 mod (소수-1)*(또다른소수-1)=1이 되는 개인키를 구함  
실행 : 평문^공개키 mod 소수곱  
![image](https://github.com/gryrryfh/Security/assets/50912987/f74fd127-d341-4114-b0b1-c9a684b471ae)  

멱승을 하므로 엄청난 컴퓨터사용량  

안정성 : 1024 비트 300자리 정수를 사용하면 푸는데 매우 오래걸림 우리들은 2048비트를 쓴다  

diffhellman  : 공개키 교환, diff헬만을 사용하면 상호간 비밀키가 생성  
원시근 : b*b^-1 mod n =1 이면 n과 b는 서로소 ex) 군Z15(n=15) b=1,2,7,11,13,14 b는 역원이 존재함  
체(field) : field의 모든 수는 곱셈상의 역원을 가짐  
diffhellman 안정성 : 공격자는 비밀정수를 구하는게 불가능 , 공개키를 구하는건 쉬운데 비밀정수를 구하는건 힘들다  
중간자공격취약성 : 서로 다른 비밀키 생성하고 공격자를 경유한 통신이 수행될 수도 있다(인증이 필요)  

대칭키 : 빠름, 많은 키 필요, 사전에 비밀키가 잘 분배되어야 함  
공개키 : 키관리, 분배 문제 해결, 하지만 많은 계산시간(전자상거래, 인터넷 뱅킹에서 사용)  
  
## 4장  해시함수와 메시지 인증코드  
  
해시함수 : 어떤 길이의 데이터를 입력해도 정해진 길이의 결과를 주는 함수  
메시지 인증코드 : 전자서명(인터넷뱅킹, 블록체인)  
  
해시함수 :아무리 큰 메시지여도 해시함수를 통과하면 일정한 길이의 메시지 다이제스트 생성-> 메시지 인증코드 생성  
계산효율 좋아야하고 구현 실현성이 있어야된다   
어떤 크기의 데이터던지 적용 가능되어야 하고 다이제스트로 해시함수를 통해 메시지를 만들수는 없다   
강한충돌 회피성 : 메시지 1과 2는 해시함수를 통과하면 다른 내용이 되어야한다  
안전해시 알고리즘(secure hash algorithm)SHA 미국 국가안보국이 개발  
sha-1, sha256, sha384, sha512 등이 있다
![image](https://github.com/gryrryfh/Security/assets/50912987/e7d1ec93-c2fe-4f9a-b531-b06380e128a1) 
알고리즘은 거의 같다  
해시함수 비교 : md5, sha-1, ripemd-160 has-160
다이제스트 길이가 길면길수록 안정적임(md5가 가장 짧다) 현재는 md5보안관련 용도로 안씀
sha-1은 충돌이 있다 그래서 256, 384, 512비트는 아직까지 안전함
블록체인에 sha 256가 블록해시 생성하는데 사용 위조변조방지를 위해 linked list방식으로 2번쓰임

메시지 인증코드 : 신원확인, 무결성 서비스, 부인방지에 쓰임.
  
대칭키 메시지 인증 : 메시지 생성->다이제스트->암호키로 암호(인증코드생성)생성,  메시지와 인증코드를 전송  
수신받은 인증코드의 다이제스트와 암호를 복호화한 후 다이제스트가 동일하면 메시지임을 인증  

공개키 메시지 인증 : 메시지 생성 ->다이제스트-> 수신자의 개인키로 메시지 인증코드 생성, 메시지, 인증코드를 보냄 
  
인증코드로 다이제스트만들고 이거랑 인증코드를 공개키로 복호화한거랑 비교해서 같으면 인증  

해시함수 없는 공개키 메시지 인증 : 메시지 전체를 개인키로 암호화,  발신자에게 전달 이걸 수신자의 공개키로 복호화
해독되면 메시지임을 인증 (오래걸림)  
해시함수를 안쓰면 시간이 많이 걸리지만 해시함수가 필요가 없다     
해시함수를 이용하면 전송량이 증가하고 생성, 검증이 빠르다(많이 쓴다)    

공유 비밀키 메시지 인증 : 송신자, 수신자가 비밀키를 공유,  송신자가 메시지에 비밀키를 붙여 다이제스트 생성  
수신자는 메시지와 다이제스트를 받는데 메시지만 때서 다이제스트 만들고 받은 다이제스트랑 같으면 인증  

HMAC : 공유 비밀키기반 메시지 인증 알고리즘(내가 사용하는 해시함수의 안정성에 따라 hmac의 안정성도 결정)  
인감(종이문서+도장), 전자문서(전자문서+전자서명)    

  
  
추가비트(1000), 메시지 길이비트로 512비트의 배수가 되도록 함   
초기벡터랑 블록1이랑 함수처리...마지막까지 반복  
압축함수 : 벡터는 160비트 20단계씩 4번      
![image](https://github.com/gryrryfh/Security/assets/50912987/8fff9dd0-67c4-47ff-8261-a311e13ebd16)    
메시지블럭을  16개의 워드로 분리 -> 17~79 워드는 특정함수로 생성, 20단계마다 사용될 워드 생성완료,  

## 5장 공개키 기반구조와 인터넷뱅킹
공개키 암호시스템 : 수신자의 공개키로 암호문을 만들고 수신자의 개인키로 복호화하면 평문이 된다 2n개키 필요
공격자가 미리 위조하면 위조사실을 파악못함 ->공동인증서(인증기관) 인증서로 등록이 되어잇으면 인증서에 인증서에 있는 공개키로 위조 확인
  
공개키 기반 구조 무지 많이 쓰인다(인터넷뱅킹, 전자화폐, 인터넷쇼핑, 예약, 전자우편)
공개키 기반 구조 : 생성, 관리, 인프라, 하드웨어, 인력, 정책, 절차
공개키 기반 구조 구성요소 : 사용자, 등록기관, 인증기관, 저장소

인증서 : 인증기관이 발행한 사이버인감증명서(실체정보+공개키+인증기관정보+전자서명(인증기관개인키)) ex)x.509, pgp 등  
인증기관 : 민간npki(금융, 증권 무역, 전자입찰  등) kisa가 최상위 인증기관  +  정부분야gpki
kisa는 최상위 인증기관, 인증기술 개발, 국제협력
외국의 경우 : 지역별로 분할되어있다, 웹사이트 보안(ssl인증서)는 몇회사가 점유를 하고 있긴하다

(사용자가 키를 만듦)사용자 키 생성 방식 : 토큰(공개키, 개인키 생성 정보 포함)생성-> 개인키, 공개키 생성 -> 인증서요청(공개키포함)->유효성확인, 응답메시지 전송->인증서는 인증서 저장   
중앙 집중형 키 생성 방식 : 토큰생성(공개키, 개인키, 인증서포함)->보관소에 저장->사용자에게 공개키, 개인키, 인증서 전송

x.509 인증서 분배, 절차 정의(내부필드, 자료구조는 정의하지 않음)
IETF의 PKIX작업반에서 표준개발

x.509 인증서형식 : 버전, 일련번호, 무슨 알고리즘인지, 인증기관, 유효기관, 인증서 주인 정보, 공개키(2048bit), 확장필드(기관, 주체 키 식별자, 배포시점), 발급자서명(앞에 내용들을 바탕으로 개인키, 서명 알고리즘을 적용하여 생성)  
인증서효력정지(개인키누설, 소속변경)
인증서 폐지목록==CRL(폐지를 실시간으로 확인은 못한다)
폐지된 인증서(일련번호, 폐지일자, CRL항목 확장(사유, 발급자, 무효일자))

OCSP온라인인증서 상태확인 프로토콜 : 온라인으로 실시간으로 확인가능
x.509 신뢰모델 : 계층적 신뢰 사용

인증서 검증 절차 : 버전필드확인->인증서 주체 확인 -> 유효기간 확인 -> 서명값 유효성 확인 -> 폐지유무확인 -> 상위발급 인증서로 반복

뱅킹 이용절차 : 로그인-전자서명-인증서비밀번호-유효성확인

공인인증 : 1999.2 고강도 암호화(SEED) 개발

공인인증 취약점 : 공인인증서는 이용자가 잘 관리해야됨(비밀번호 누출 x), 악성코드 유포경로인 activex설치 요구

사설인증 : 문제점(회사마다 안정성 천차만별, 서비스 질 들쭉날쭉)

대체 기술 : 공인인증서 우월적 지위 폐지 사설인증방식(noplugin, 지문, 간편비밀번호)


## 6장 인터넷 보안 프로토콜
인터넷 프로토콜의 보안 취약성 : 처음엔 보안이 중요하지 않았음  
오류체크를 위한 헤더검사합(checksum) 너무 쉽게 계산이 된다  
그래서 보안프로토콜 개발(ipv6와 연계해서 1995년에 개발)  
96년에 tls를 표준화로 만듬  
보안서비스 : 무결성, 인증기능, 위조, 기밀성, 재전송 감지 폐기  
ip보안 프로토콜 : 키관리프로토콜, 인증헤더프로토콜, 캡슐화 보안페이로드, ip압축프로토콜  
보안연계(security association) : 보안연계 설정, 해제 기능 
보안연계 운영모드 
트랜스포트모드 : 발신지ab, 수신지 a,b
터널모드 : ipsec이 적용되지 않은 게이트웨이들 사이에  작용
esp프로토콜 : 대칭키 암호 알고리즘(기밀성, 인증, 무결성, 재전송 폐기)
터널모드는 많은 대역폭을 사용한다, 
ah는 ip를 바꾸면 바꾸는데 (높은수준 인증)
esp는 
복호화 : 인증 다음에 복호화
암호화 : 복호화 다음에 인증

## 7장  ISAKMP
ISAKMP 보안연계 혐상 수립 수정의 절차, 패킷 형식 정의
협상단계 : 보안연계 수립
  
